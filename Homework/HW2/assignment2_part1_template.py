#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Jul  1 17:16:06 2023

@author: ari
"""
import math

import coppeliasim_zmqremoteapi_client as zmq
import matplotlib.pyplot as plt
import numpy as np
import ecse275utils as util
from queue import PriorityQueue


# %%
def manhatten_distance(x1, x2, y1, y2):
    """
    Helper method that calculates the distance between two points

    :param x1: x1 coordinate
    :param x2: x2 coordinate
    :param y1: y1 coordinate
    :param y2: y2 coordinate
    :return: the distance between two points
    """

    return abs(x1 - x2) + abs(y1 - y2)


class ASTAR:
    """
    The key object here is the state object which is a dictionary to track our state
    
    it comprises the following
    'explored_set' is a list for you to populate with individual tuples of (row,column)
    index for nodes that have been explored
    'open_set' is a list for you to populate with nodes that have yet to be explored.
    We initialized it for you with one element, the start point.
    'world_map' is the grid map that contains information about the grid world,
    obstacles are 1, and the goal is 2, open space is 0
    'world_map_g' is the grid that should store the cost to go values corresponding
    to that row and column in the world_map
    'world_map_h' is the grid that should store the cost to reach/come values corresponding
    to that row and column in the world_map
    'parents_map' is a 4 dimensional array, the first two dimensions are the same dimensions
    as the world map, the next two are for storing the row column values corresponding to the
    parent cell for that given position in the grid map
    """

    def __init__(self, world_map, start, end):
        """
        Parameters
        ----------
        world_map :gridmap object
            This object is generated by the ECSE275 Util Library and contains the world information
        start : 2-element tuple
            start point x and y pixel coordinates
        end : 2-element tuple
            end point in x and y pixel coordinates

        Returns
        -------
        None.
        """

        self.state = {'explored_set': [],
                      'open_set': [list(np.flip(start))],
                      'world_map': world_map,
                      'world_map_g': np.zeros_like(world_map),
                      'world_map_h': np.zeros_like(world_map),
                      'parents_map': np.zeros((world_map.shape[0], world_map.shape[1], 2))}

        self.world_dims = world_map.shape
        self.end_point = np.flip(end)
        self.start_point = np.flip(start)
        self.traced_path_rc = None
        self.trace_path_xyzq = None

        self.state['world_map'][self.end_point[0], self.end_point[1]] = 2
        self.state['world_map_h'][self.start_point[0], self.start_point[1]] = self.get_cost_to_goal(self.start_point[0],
                                                                                                    self.start_point[1])

    def get_parent_point(self, grid_row, grid_col):
        """
        Parameters
        ----------
        grid_row : int
            the row position of the cell you are querying
        grid_col: int
            the column position of the cell you are querying
        Returns
        -------
        tuple of the parent cell location as a row and column in the grid world

        """

        parent_r = int(self.state['parents_map'][grid_row, grid_col][0])
        parent_c = int(self.state['parents_map'][grid_row, grid_col][1])

        return parent_r, parent_c

    def set_parent_point(self, grid_row_parent, grid_col_parent):
        """
        Parameters
        ----------
        grid_row_parent : int
            the row location of the parent cell
        grid_col_parent : int
            the column location of the parent cell

        Returns
        -------
        2-element numpy array
            it packages the information into the numpy array for storage.

        """

        return np.array([grid_row_parent, grid_col_parent])

    def get_cost_to_reach(self, grid_row_parent, grid_col_parent):
        """
        Parameters
        ----------
        grid_row_parent : int
            row location of the parent cell
        grid_col_parent : int
            column location of the parent cell

        Returns
        -------
        float
            the cost to reach the current cell

        """
        # TODO: Fix once I know what the current point is
        # return distance(grid_row_parent, gridrow, grid_col_parent, grid_col_current)
        return manhatten_distance(grid_row_parent, self.state[0], grid_col_parent, self.state[1])

    def get_cost_to_goal(self, gridrow, gridcol):
        """
        Compute this using the Manhattan distance

        Parameters
        ----------
        grid_row_parent : int
            row location of the parent cell
        grid_col_parent : int
            column location of the parent cell

        Returns
        -------
        float
            the estimated cost to reach the goal

        """
        # TODO: Check if the variables are correct once I read the assignment
        return manhatten_distance(gridrow, self.end_point[0], gridcol, self.end_point[1])

    def get_cost(self, grid_row, grid_col):
        """

        :param grid_row:
        :param grid_col:
        :return:
        """

        return self.get_cost_to_reach(grid_row, grid_col) + self.get_cost_to_goal(grid_row, grid_col)

    def search_surrounding_nodes(self, grid_row, grid_col):
        """
        Function to add the surrounding nodes around a cell into the open set.

        1. For each node surrounding the current node do the following:
            a. check if it is in the workspace bounds
            b. check if it is already explored or in the open set
            c. if it is not then add it to the the open set
            d. calculate the cost to go and the cost to come and store them

        2. Remove the current node from the open set and add it to the explored set


        Parameters
        ----------
        grid_row : int
            the row position of the cell you are querying
        grid_col: int
            the column position of the cell you are querying

        Returns
        -------
        None.

        """
        # Create the list of surrounding nodes
        surrounding_nodes = [self.process_node(grid_row + i, grid_col + j) for i in [-1, 1] for j in [-1, 1]]

        # Check each node in the list
        for node in surrounding_nodes:
            # TODO: Fill in the rest of this
            # Check if the node is in the workspace bounds
            if node == 0:
                # Empty Space - Add to open set
                pass
            elif node == 1:
                # Obstacle - Remove from open set and add to explored set
                pass
            elif node == 2:
                # Goal - Remove from open set and add to explored set
                pass


    def process_node(self, grid_row, grid_col):
        """
        In this function we want to:
        1. check if we reach the goal
        2. else check if we hit an obstacle, if so remove it from the open set and immediately add it
        to the explored set
        3. else execute the search of surrounding nodes function
        
        Parameters
        ----------
        grid_row : int
            the row position of the cell you are querying
        grid_col: int
            the column position of the cell you are querying

        Returns
        -------
        int
            the state of the cell, either 2 for goal, 1 for obstacle, 0 for empty space
        """
        # TODO: Fill in the rest of this
        # your code here
        if grid_row == self.end_point[0] and grid_col == self.end_point[1]:
            return 2
        elif self.state['world_map'][grid_row, grid_col] == 1:
            return 1
        return 0

    def visualize_state(self):
        """

        Returns
        -------
        None.

        """

        for pt in self.state['explored_set']:
            plt.plot(pt[1], pt[0], '.', markersize=4, color="yellow")
        for pt in self.state['open_set']:
            plt.plot(pt[1], pt[0], '.', markersize=2, color="green")

        if self.traced_path_rc is not None:
            trace_vector = np.array(self.traced_path_rc)
            plt.plot(trace_vector[:, 1], trace_vector[:, 0], linewidth=2)

    def run(self, max_iter=1000):
        """
        This function will run ASTAR by
        1. Checking the open set and ranking the nodes by the cost.
        2. Process the lowest cost node until we find the goal or hit the maximum number of iterations
        3. Once this is done the path through the grid map must be traced backward by looking up the
        parent nodes until the start point
        4. Return the paths


        Parameters
        ----------
        max_iter : int, optional
            number of iterations to run A STAR The default is 1000.

        Returns
        -------
        list
            sequence of 2D points (row,column) for each cell of the path found by ASTAR
        """

        # TODO: Fill in the rest of this
        #

        # Initialize the path node list with the start point in it
        pq = PriorityQueue()
        pq.put((0, self.start_point))

        # your code here
        while (not pq.empty()) and (max_iter > 0):
            max_iter -= 1

            # Get the next node to process
            current_node = pq.get()

            # Check the current node
            state = self.process_node(current_node[1][0], current_node[1][1])

            if state == 2:
                # We have reached the goal
                break

            elif state == 1:
                # We have hit an obstacle
                continue

            else:
                # We have an empty space
                pass

            # Process the surrounding nodes
            self.search_surrounding_nodes(current_node[1][0], current_node[1][1])
            




        return path_node_list


# %%
'''
if __name__ == '__main__':
    ''
     This main function initializes the world from the vision sensor in coppelia sim.
     Once this is done it creates an ASTAR object and then runs ASTAR for the specified number of iterations
     It uses the path list to define a real path in coppelia sim from which the robot will follow.
     ''

    client = zmq.RemoteAPIClient()
    sim = client.getObject('sim')

    worldmap = util.gridmap(sim, 5.0)
    worldmap.inflate_obstacles(num_iter=10)  # YOU CAN MODIFY THE INFLATION ITERATIONS
    worldmap.normalize_map()
    worldmap.plot(normalized=True)

    goal = sim.getObjectHandle("/goal_point")
    goal_world = sim.getObjectPosition(goal, sim.handle_world)
    goal_grid = worldmap.get_grid_coords(goal_world)
    worldmap.plot_point(goal_grid)
    robot = sim.getObjectHandle("/Pure_Robot/Dummy")
    start_world = sim.getObjectPosition(robot, sim.handle_world)
    start_grid = worldmap.get_grid_coords(start_world)
    worldmap.plot_point(start_grid, color='red')

    astar = ASTAR(worldmap.norm_map, start_grid, goal_grid)
    trace_grid = astar.run(max_iter=50000)  # YOU CAN MODIFY THE ASTAR ITERATIONS
    astar.visualize_state()

    trace_grid = np.fliplr(np.array(trace_grid))
    m, n = trace_grid.shape
    trace_grid = np.hstack((trace_grid, np.zeros((m, 1))))
    trace_world = worldmap.get_world_coords(np.array(trace_grid).reshape((-1, 3)))
    coppelia_path = util.generate_path_from_trace(sim, trace_world, 100)

    trackpoint = sim.getObjectHandle("/track_point")
    util.execute_path(coppelia_path, sim, trackpoint, robot, thresh=0.1)
'''
