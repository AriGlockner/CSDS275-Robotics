#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Jul  1 17:16:06 2023

@author: zxc703
"""
import coppeliasim_zmqremoteapi_client as zmq
import matplotlib.pyplot as plt
import numpy as np
import ecse275utils as util


def manhattan_distance(x1, y1, x2, y2):
    """
    :param x1: x coordinate of the first point
    :param y1: y coordinate of the first point
    :param x2: x coordinate of the second point
    :param y2: y coordinate of the second point
    :return: the manhattan distance between the two points
    """
    return abs(x1 - x2) + abs(y1 - y2)


# %%
class ASTAR:
    """
    The key object here is the state object which is a dictionary to track our state

    it comprises the following
    'explored_set' is a list for you to populate with individual tuples of (row,column) index for nodes that have been explored
    'open_set' is a list for you to populate with nodes that have yet to be explored. We initialized it for you with one element, the start point.
    'world_map' is the grid map that contains information about the grid world, obstacles are 1, and the goal is 2, open space is 0
    'world_map_g' is the grid that should store the cost to go values corresponding to that row and column in the world_map
    'world_map_h' is the grid that should store the cost to reach/come values corresponding to that row and column in the world_map
    'parents_map' is a 4 dimensional array, the first two dimensions are the same dimensions as the world map, the next two are for storing the row column values corresponding to the parent cell for that given position in the grid map
    """

    def __init__(self, world_map, start, end):
        """
        Parameters
        ----------
        world_map :gridmap object
            This object is generated by the ECSE275 Util Library and contains the world information
        start : 2-element tuple
            start point x and y pixel coordinates
        end : 2-element tuple
            end point in x and y pixel coordinates

        Returns
        -------
        None.

        """

        self.state = {'explored_set': [],
                      'open_set': [list(np.flip(start))],
                      'world_map': world_map,
                      'world_map_g': np.zeros_like(world_map),
                      'world_map_h': np.zeros_like(world_map),
                      'parents_map': np.zeros((world_map.shape[0], world_map.shape[1], 2))}

        self.world_dims = world_map.shape
        self.end_point = np.flip(end)
        self.start_point = np.flip(start)
        self.traced_path_rc = None
        self.trace_path_xyzq = None

        self.state['world_map'][self.end_point[0], self.end_point[1]] = 2
        self.state['world_map_h'][self.start_point[0], self.start_point[1]] = self.get_cost_to_goal(self.start_point[0],
                                                                                                    self.start_point[1])

    def get_parent_point(self, gridrow, gridcol):
        """
        Parameters
        ----------
        gridrow : int
            the row position of the cell you are querying
        gridcol: int
            thee column position of the cell you are querying
        Returns
        -------
        tuple of the parent cell location as a row and column in the grid world

        """

        parent_r = int(self.state['parents_map'][gridrow, gridcol][0])
        parent_c = int(self.state['parents_map'][gridrow, gridcol][1])

        return parent_r, parent_c

    def set_parent_point(self, gridrow_parent, gridcol_parent):
        """


        Parameters
        ----------
        gridrow_parent : int
            the row location of the parent cell
        gridcol_parent : int
            the column location of the parent cell

        Returns
        -------
        2-element numpy array
            it packages the information into the numpy array for storage.

        """

        return np.array([gridrow_parent, gridcol_parent])

    def get_cost_to_reach(self, gridrow_parent, gridcol_parent):
        """

        Parameters
        ----------
        gridrow_parent : int
            row location of the parent cell
        gridcol_parent : int
            column location of the parent cell

        Returns
        -------
        float
            the cost to reach the current cell

        """
        return manhattan_distance(gridrow_parent, gridcol_parent, self.start_point[0], self.start_point[1])

    def get_cost_to_goal(self, gridrow, gridcol):
        """
        Compute this using the Manhattan distance

        Parameters
        ----------
        gridrow : int
            row location of the parent cell
        gridcol : int
            column location of the parent cell

        Returns
        -------
        float
            the estimated cost to reach the goal

        """
        return manhattan_distance(gridrow, gridcol, self.end_point[0], self.end_point[1])

    def sort_by(self, node):
        """
        Function to sort the open set by the cost
        :param node: the node to get the heuristic cost for
        :return: the summed cost of the cost to goal and cost to reach
        """
        return self.get_cost_to_reach(node[0], node[1]) + self.get_cost_to_goal(node[0], node[1])

    def search_surrounding_nodes(self, gridrow, gridcol):
        """
        Function to add the surrounding nodes around a cell into the open set.

        1. For each node surrounding the current node do the following:
            a. check if it is in the workspace bounds
            b. check if it is already explored or in the open set
            c. if it is not then add it to the the open set
            d. calculate the cost to go and the cost to come and store them

        2. Remove the current node from the open set and add it to the explored set


        Parameters
        ----------
        gridrow : int
            the row position of the cell you are querying
        gridcol: int
            thee column position of the cell you are querying

        Returns
        -------
        None.

        """
        # TODO: Check if working
        # Get the surrounding nodes
        surrounding_nodes = []
        for r in [gridrow - 1, gridrow + 1]:
            surrounding_nodes.append([r, gridcol])
        for c in [gridcol - 1, gridcol + 1]:
            surrounding_nodes.append([gridrow, c])

        print('surrounding_nodes', surrounding_nodes)

        # For each of the surrounding nodes, get the row and column values
        for node in surrounding_nodes:
            # Check if the neighbor node is in the workspace bounds
            if 0 <= node[0] < self.world_dims[0] and 0 <= c < self.world_dims[1]:
                row = node[0]
                col = node[1]
                # Check if the neighbor node is not an obstacle
                if self.state['world_map'][row, col] != 1:
                    # Check if the node is not already explored or in the open set
                    if [r, c] not in self.state['open_set'] and [r, c] not in self.state['explored_set']:
                        # Add the node to the open set
                        self.state['open_set'].append([r, c])

                        # Calculate the cost to go and the cost to come and store them
                        self.state['world_map_h'][r, c] = self.get_cost_to_goal(r, c)
                        self.state['world_map_g'][r, c] = self.get_cost_to_reach(gridrow, gridcol)
                        self.state['parents_map'][r, c] = self.set_parent_point(gridrow, gridcol)

        # Remove the current node from the open set and add it to the explored set
        if [gridrow, gridcol] in self.state['open_set']:
            self.state['open_set'].remove([gridrow, gridcol])

    def process_node(self, gridrow, gridcol):
        """
        In this function we want to:
        1. check if we reach the goal
        2. else check if we hit an obstacle, if so remove it from the open set and immediately add it to the explored set
        3. else execute the search of surrounding nodes function


        Parameters
        ----------
        gridrow : int
            the row position of the cell you are querying
        gridcol: int
            thee column position of the cell you are querying

        Returns
        -------
        int
            the state of the cell, either 2 for goal, 1 for obstacle, 0 for empty space
        """
        # TODO: Check if working
        # print('Processing node:', gridrow, gridcol, 'State:', self.state['world_map'][gridrow, gridcol])
        print(self.start_point[0] < gridrow < self.end_point[0], self.start_point[1] < gridcol < self.end_point[1])

        state = self.state['world_map'][gridrow, gridcol]

        # Check if we reach the goal
        if state == 2:
            return 2
        # Check if we hit an obstacle
        elif state == 1:
            # TODO: Figure out why the initial position of the robot is an obstacle
            # Remove it from the open set and immediately add it to the explored set
            self.state['open_set'].remove([gridrow, gridcol])
            self.state['explored_set'].append([gridrow, gridcol])
            return 1
        # Execute the search of surrounding nodes function
        else:
            self.state['open_set'].remove([gridrow, gridcol])
            self.state['explored_set'].append([gridrow, gridcol])
            self.search_surrounding_nodes(gridrow, gridcol)
            return 0

    def visualize_state(self):
        """

        Returns
        -------
        None.

        """

        for pt in self.state['explored_set']:
            plt.plot(pt[1], pt[0], '.', markersize=4, color="yellow")
        for pt in self.state['open_set']:
            plt.plot(pt[1], pt[0], '.', markersize=2, color="green")

        if self.traced_path_rc is not None:
            trace_vector = np.array(self.traced_path_rc)
            plt.plot(trace_vector[:, 1], trace_vector[:, 0], linewidth=2)

    def run(self, max_iter=1000):
        """
        This function will run ASTAR by
        1. Checking the open set and ranking the nodes by the cost.
        2. Process the lowest cost node until we find the goal or hit the maximum number of iterations
        3. Once this is done the path through the grid map must be traced backward by looking up the parent nodes until the start point
        4. Return the paths


        Parameters
        ----------
        max_iter : int, optional
            number of iterations to run A STAR The default is 1000.

        Returns
        -------
        list
            sequence of 2D points (row,column) for each cell of the path found by ASTAR
        """
        # TODO: Fill this in
        #print(self.state['world_map'])

        # Initialize the iteration counter
        iter_count = 0

        print(self.start_point)
        print(self.end_point)

        # While the open set is not empty and the maximum number of iterations is not reached
        while self.state['open_set'] and iter_count < max_iter:
            # Sort the open set by the cost
            # TODO: maybe iterate through all and find lowest rather than sorting O(n) vs O(nlog(n))
            # TODO: Check if there is a bug on the next line
            self.state['open_set'].sort(key=self.sort_by, reverse=True)
            print('open_set', self.state['open_set'])

            # Get the node with the lowest cost
            node = self.state['open_set'][0]
            # Process the node
            state = self.process_node(node[0], node[1])
            plt.plot(node[1], node[0], '.', markersize=4, color="black")
            print('node', node, 'State:', state)
            # print('node', node, 'State:', state)
            # If we reach the goal
            if state == 2:
                # Trace the path through the grid map backward by looking up the parent nodes until the start point
                self.traced_path_rc = self.trace_path(node[0], node[1])
                # Return the paths
                return self.traced_path_rc
            # Increment the iteration counter
            iter_count += 1
        print(max_iter, iter_count)
        plt.show()
        # If we reach the maximum number of iterations
        return None

    def trace_path(self, row, col):
        """
        This function will trace the path through the grid map backward by looking up the parent nodes until the start point
        :param row:
        :param col:
        :return: the traced path
        """
        # TODO: Check if working
        # Get the prior node
        prior = self.state['parents_map'][row, col]

        # If we reach the start point
        if prior[0] == self.start_point[0] and prior[1] == self.start_point[1]:
            return [[row, col]]
        # If we don't reach the start point
        else:
            return self.trace_path(prior[0], prior[1]) + [[row, col]]


# %%

if __name__ == '__main__':
    '''
    This main function initializes the world from the vision sensor in coppelia sim.
    Once this is done it creates an ASTAR object and then runs ASTAR for the specified number of iterations
    It uses the path list to define a real path in coppelia sim from which the robot will follow.
    '''
    print('starting from coppelia sim')
    # Initialize the world
    client = zmq.RemoteAPIClient()
    sim = client.getObject('sim')
    print('Connected to remote API server')

    # Grab the world map from coppeliasim
    worldmap = util.gridmap(sim, 5.0)
    worldmap.inflate_obstacles(num_iter=10)  # YOU CAN MODIFY THE INFLATION ITERATIONS
    worldmap.normalize_map()
    worldmap.plot(normalized=True)

    # Grab the goal positions
    goal = sim.getObjectHandle("/goal_point")
    goal_world = sim.getObjectPosition(goal, sim.handle_world)
    goal_grid = worldmap.get_grid_coords(goal_world)
    worldmap.plot_point(goal_grid)

    # Grab the robot positions
    robot = sim.getObjectHandle("/Pure_Robot/Dummy")
    start_world = sim.getObjectPosition(robot, sim.handle_world)
    start_grid = worldmap.get_grid_coords(start_world)
    worldmap.plot_point(start_grid, color='red')

    # Run A*
    astar = ASTAR(worldmap.norm_map, start_grid, goal_grid)
    trace_grid = astar.run(max_iter=1000)  # 50000 - YOU CAN MODIFY THE ASTAR ITERATIONS
    astar.visualize_state()

    # Check if A* found a path
    if trace_grid is None:
        print('no path found')
    else:
        # Convert the path to world coordinates
        trace_grid = np.fliplr(np.array(trace_grid))
        m, n = trace_grid.shape
        # Trace the path in coppelia sim
        trace_grid = np.hstack((trace_grid, np.zeros((m, 1))))
        trace_world = worldmap.get_world_coords(np.array(trace_grid).reshape((-1, 3)))
        coppelia_path = util.generate_path_from_trace(sim, trace_world, 100)

        # Execute the path in coppelia sim
        trackpoint = sim.getObjectHandle("/track_point")
        util.execute_path(coppelia_path, sim, trackpoint, robot, thresh=0.1)
