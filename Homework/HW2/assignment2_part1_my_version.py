import numpy as np


class State:
    def __init__(self, x, y, cost, parent):
        """
        This function should initialize the state variables
        :param x: the x coordinate of the position of this state
        :param y: the y coordinate of the position of this state
        :param cost: the manhattan distance between the current state and the goal state
        :param parent: the prior state of the robot
        """
        self.x = x
        self.y = y
        self.cost = cost
        self.parent = parent
        pass

    def __eq__(self, other):
        """
        :param other: the other state to compare to the current state
        :return: True if the current state is the same as the other state, False otherwise
        """
        return self.x == other.x and self.y == other.y

    def get_cost_to_reach(self, current_state):
        """
        This function should return the cost to reach the current state from the parent state
        :param current_state: the current state of the robot
        :return: the cost to reach the current state from the parent state
        """
        return abs(current_state.x - self.x) + abs(current_state.y - self.y)

    def get_cost_to_goal(self):
        """
        This function should return the cost to reach the goal from the current state
        :return: the cost to reach the goal from the current state
        """
        return self.cost

    def get_total_cost(self, current_state):
        """
        This function should return the total cost of the current state
        :param current_state: the current state of the robot
        :return: the total cost of the current state
        """
        return self.get_cost_to_goal() + self.get_cost_to_reach(current_state)

    def get_parent(self):
        """
        This function should return the parent state of the current state
        :return: the parent state of the current state
        """
        return self.parent

    def get_position(self):
        """
        This function should return the position of the current state
        :return: the position of the current state
        """
        return self.x, self.y

    def get_neighbor_nodes(self):
        """
        This function should return all possible moves from the current state
        :return: all possible moves from the current state
        """
        return [(self.x + 1, self.y), (self.x - 1, self.y), (self.x, self.y + 1), (self.x, self.y - 1)]

    def trace_path(self):
        """
        This function should return the path from the start state to the current state
        :return: the path from the start state to the current state
        """
        if self.parent is None:
            return [(self.x, self.y)]
        else:
            return self.parent.trace_path() + [(self.x, self.y)]

class ASTAR:
    """
    The key object here is the state object which is a dictionary to track our state

    it comprises the following
    'explored_set' is a list for you to populate with individual tuples of (row,column)
    index for nodes that have been explored
    'open_set' is a list for you to populate with nodes that have yet to be explored.
    We initialized it for you with one element, the start point.
    'world_map' is the grid map that contains information about the grid world,
    obstacles are 1, and the goal is 2, open space is 0
    'world_map_g' is the grid that should store the cost to go values corresponding
    to that row and column in the world_map
    'world_map_h' is the grid that should store the cost to reach/come values corresponding
    to that row and column in the world_map
    'parents_map' is a 4 dimensional array, the first two dimensions are the same dimensions
    as the world map, the next two are for storing the row column values corresponding to the
    parent cell for that given position in the grid map
    """

    def __init__(self, world_map, start, end):
        """
        Parameters
        ----------
        world_map :gridmap object
            This object is generated by the ECSE275 Util Library and contains the world information
        start : 2-element tuple
            start point x and y pixel coordinates
        end : 2-element tuple
            end point in x and y pixel coordinates

        Returns
        -------
        None.
        """

        self.state = {'explored_set': [],
                      'open_set': [list(np.flip(start))],
                      'world_map': world_map,
                      'world_map_g': np.zeros_like(world_map),
                      'world_map_h': np.zeros_like(world_map),
                      'parents_map': np.zeros((world_map.shape[0], world_map.shape[1], 2))}

        self.world_dims = world_map.shape
        self.end_point = np.flip(end)
        self.start_point = np.flip(start)
        self.traced_path_rc = None
        self.trace_path_xyzq = None

        self.state['world_map'][self.end_point[0], self.end_point[1]] = 2
        self.state['world_map_h'][self.start_point[0], self.start_point[1]] = self.get_cost_to_goal(self.start_point[0],
                                                                                                    self.start_point[1])
        pass

    def run(self, max_iter=1000):
        """
        This function should run the A* algorithm until the end point is reached or the max_iter is reached
        :param max_iter: the maximum number of iterations to run the algorithm
        :return: the path as a list of tuples of (row,column) index for each step in the path from start to end
        """
        for i in range(max_iter):
            current_state = self.get_next_state()
            self.state['explored_set'].append(current_state.get_position())
            if current_state == self.end_point:
                current_state.trace_path(current_state)
                return self.traced_path_rc
            self.update_neighbors(current_state)
        return None

    def solveAStar(self):
        """
        This function should return the path as a list of tuples of (row,column)
        index for each step in the path from start to end
        """
        while self.state['open_set']:
            current_state = self.get_next_state()
            self.state['explored_set'].append(current_state.get_position())
            if current_state == self.end_point:
                self.trace_path(current_state)
                return self.traced_path_rc
            self.update_neighbors(current_state)
        return None